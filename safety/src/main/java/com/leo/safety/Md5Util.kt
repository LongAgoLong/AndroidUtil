package com.leo.safetyimport androidx.annotation.NonNullimport com.leo.safety.enume.Md5Modeimport java.security.MessageDigestimport java.util.*/** * @author Ari * MD5加密工具 */object Md5Util {    private val hexDigits = arrayOf("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f")    private fun byteArrayToHexString(b: ByteArray): String {        val resultSb = StringBuffer()        for (i in b.indices) {            resultSb.append(byteToHexString(b[i]))        }        return resultSb.toString()    }    private fun byteToHexString(b: Byte): String {        var n = b.toInt()        if (n < 0)            n += 256        val d1 = n / 16        val d2 = n % 16        return hexDigits[d1] + hexDigits[d2]    }    @JvmOverloads    fun encrypt(@NonNull origin: String, @Md5Mode mode: Int = Md5Mode.LOWERCASE): String {        try {            val md = MessageDigest.getInstance("MD5")            val resultString = byteArrayToHexString(md.digest(origin.toByteArray()))            return if (mode == Md5Mode.UPPERCASE) {                resultString.toUpperCase(Locale.ROOT)            } else {                resultString            }        } catch (ex: Exception) {            ex.printStackTrace()        }        return origin    }}